# 所需包：
- Flask-login：管理已经登录的用户对话
- Werkzeug： 计算密码散列值并进行核对
- itsdangerous：生成并核对加密安全令牌
- flask-mail：发送与认证电子邮件
- flask-bootstrap：HTML 模板
- flask-wtf：Web 表单
- isdangerouse 加密认证

# 知识点
  ## @property
  可以将类方法变为类属性，并且变为类属性后就不能在被直接修改，相当于设了一层限制
```
    class Person(object):
	def __init__(self,first_name,last_name):
		self.first_name  = first_name
		self.last_name = last_name
	@property
	def full_name(self):
		return "%s %s" %(self.first_name,self.last_name)
    
>>>person = Person('Mike','Driscoll')
>>> person.full_name
'Mike Driscoll'
>>> person.full_name='as'   #尝试修改
Traceback (most recent call last):
  File "<pyshell#16>", line 1, in <module>
    person.full_name='as'
AttributeError: can't set attribute
```
可是可以用property+setter的方法让它变得可以修改
```
from decimal import Decimal
>>> class Fees(object):
	def __init__(self):
		self._fee = None
	@property
	def fee(self):
		return self._fee
	@fee.setter
	def fee(self,value):
		if isinstance(value,str):
			self._fee = Decimal(value)
		elif isinstance(value,Decimal):
			self._fee = value
			
>>> f = Fees()
f.fee = "1"
>>> f.fee
Decimal('1')
>>> f.fee=46
>>> f.fee
Decimal('1')
```
## with self.assertRaises(AttributeError) 
```
def test_no_password_getter(self):
		u = User(password = 'cat')
		with self.assertRaises(AttributeError):  #访问不可访问的属性时，验证抛出的异常是否是定义好的
			u.password
```
## 蓝本（new，一个路由就需要一个新的蓝本？）
1. 创建蓝本  
```
```
2. 定义蓝本中的路由和视图函数

3. 注册蓝本

# Flask-Login (http://docs.jinkan.org/docs/flask-login/)
方法|说明
----|----
is_authenticated() | 如果用户一登录, 返回 True, 否则返回 False
is_active() | 如果允许用户登录, 返回 True, 否则返回 False. 如果要禁用账户, 可以返回 False
is_anonymous() | 对普通用户必须返回 False
get_id() | 必须返回用户的唯一标识符, 使用 Unicode 编码字符串

不过如果让类从usermixin继承的话，就不用再定义这些类了
	更多详细功能：(https://amberno1111.github.io/2016/03/22/Flask/Flask-Login%E7%9A%84%E4%BD%BF%E7%94%A8/)
- 使用到的东西
1. flask_login的初始化
```
#******登录
login_manager = LoginManager()
login_manager.session_protection = 'strong'#设置安全等级
login_manager.login_view = 'auth.login' #设置登录视图名称
```
2. 回调函数
:	要使用Flask-Login扩展，你必须在数据库模型文件(models.py)中提供一个回调函数user_loader，这个回调函数用于从会话中存储的用户ID重新加载用户对		象。它应该接受一个用户的id作为输入，返回相应的用户对象。
3. 保护路由，保护路由只让认证用户访问

4. 模板中使用的时候,如果需要进行用户是否登录判断， current_user.is_authenticated()记得加括号！！！
```
	{% extends "base.html" %}

{% block title %}Flasky{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Hello, 
	{% if    current_user.is_authenticated() %}
		{{ current_user.name}}
	{% else %}
		Stranger
	{% endif %}</h1>
</div>
{% endblock %}
```
# Flask-wtf
1. FlaskForm 是比 Form更更新的form类，现在还是使用FlaskForm比较好吧，虽然不知道树里为啥两个都用 
# 数据库修改
- 每次修改完表后，要更新数据库
- 更新models里面的内容的话，先要用 python 的的migrate语句（注意在这前要在虚拟环境中安装flask-migrate）即 python 主程序.py db migrate
# 用户注册功能
1. form.py中创建新的表单
```
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email,Required,Length,Email,Regexp,EqualTo
from flask_wtf import Form
from wtforms import ValidationError
from ..models import User

class LoginForm(FlaskForm):   #用户登录
    email = StringField('Email', validators=[DataRequired(), Length(1, 64),
                                             Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    remember_me = BooleanField('Keep me logged in')
    submit = SubmitField('Log In')

class RegistrationForm(Form):   #用户注册
	email = StringField('Email',validators=[Required(),Length(1,64),Email()])
	
	name = StringField('Username',validators=[Required(),Length(1,64),Regexp('^[A-Za-z][A-Za-z0-9_.]*$',0,'Usernames must hava only letters,' 'numbers,dots or underscores')])#确保name字段只包含字母，数字，下划线，等号
	password = PasswordField('Password',validators=[Required(),EqualTo('password2',message='Password must match.')])#验证两个密码是否一致
	password2 = PasswordField('Confirm password',validators=[Required()])
	submit = SubmitField('Register')

	def validate_email(self,field):  #验证字段函数
		if User.query.filter_by(email = field.data).first():
			raise ValidationError('Email already registered')
	def validate_name(self,field):
		if User.query.filter_by(name = field.data).first():
			raise ValidationError('Username already in use')

```

2. 在views.py中添加新的视图函数
```
	@auth.route('/register',methods=['GET','POST'])
def register():
	form = RegistrationForm()
	print(form.data['email'])
	if form.validate_on_submit():
		user = User( email=form.data['email'],name=form.data['name'],password=form.data['password'])
		db.session.add(user)
		#db.session.commit()
		flash('Yon can now login')
		return redirect(url_for('auth.login'))
	return render_template('auth/register.html',form=form)
```
3. 建立模板文件html
```
	{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky - Login{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Register</h1>
</div>
<div class="col-md-4">
    {{ wtf.quick_form(form) }}
</div>
{% endblock %}
```
# 8.6 用户确认
- 实现用户邮箱认证的功能，传输加密的序列号
(http://einverne.github.io/post/2017/08/python-itsdangerous-token.html)
- 实现带时间戳的序列化
```
	 from itsdangerous import TimedSerializer 
	 s=TimedSerializer('secret-key')
	s.dumps([1,2,3,4])
	 s.loads('[1, 2, 3, 4].DlGEjg.1yG-U7iBk92FBYAZLezoBv2mfJs')
```
需要哪一个功能就导入哪一个功能
- dump()
生成加密签名
- loads()
 解码
 
